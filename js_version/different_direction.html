<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <title>Bidirectional Graph with Multiple Links</title>
    <style>
        .link {
            fill: none;
            stroke: #666;
            stroke-width: 2px;
        }

        .node circle {
            fill: #ccc;
            stroke: #333;
            stroke-width: 2px;
            cursor: pointer;
        }

        .node text {
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }

        .edge-label {
            fill: #000;
            font-family: Arial, sans-serif;
            font-size: 12px;
            pointer-events: none;
        }
    </style>
</head>
<body>

<svg width="800" height="400"></svg>

<script>
    const width = 800, height = 400;

    // Data
    const nodes = [
        {id: 'A', x: 200, y: 200},
        {id: 'B', x: 600, y: 200},
    ];

    const links = [
        {source: 'A', target: 'B', label: 'Relation 1'},
        {source: 'B', target: 'A', label: 'Relation 2'},
        {source: 'A', target: 'B', label: 'Relation 3'},
        {source: 'B', target: 'A', label: 'Relation 4'},
    ];

    // Create SVG
    const svg = d3.select('svg');

    // Create groups for links and nodes
    const linkGroup = svg.append('g').attr('class', 'links');
    const nodeGroup = svg.append('g').attr('class', 'nodes');
    const labelGroup = svg.append('g').attr('class', 'labels');

    // Simulation
    const simulation = d3.forceSimulation(nodes)
        .force('link', d3.forceLink(links).id(d => d.id).distance(200))
        .force('charge', d3.forceManyBody().strength(-500))
        .force('center', d3.forceCenter(width / 2, height / 2))
        .on('tick', ticked);

    // Draw links
    const link = linkGroup.selectAll('.link')
        .data(links)
        .enter()
        .append('path')
        .attr('class', 'link');

    // Draw edge labels
    const edgeLabels = labelGroup.selectAll('.edge-label')
        .data(links)
        .enter()
        .append('text')
        .attr('class', 'edge-label')
        .attr('text-anchor', 'middle')
        .text(d => d.label);

    // Draw nodes
    const node = nodeGroup.selectAll('.node')
        .data(nodes)
        .enter()
        .append('g')
        .attr('class', 'node')
        .call(d3.drag()
            .on('start', dragStarted)
            .on('drag', dragged)
            .on('end', dragEnded));

    node.append('circle')
        .attr('r', 20);

    node.append('text')
        .attr('dy', 4)
        .attr('text-anchor', 'middle')
        .text(d => d.id);

    // Offset calculation for curved paths
    function computePath(d, i) {
        const linksBetweenNodes = links.filter(link =>
            (link.source.id === d.source.id && link.target.id === d.target.id) ||
            (link.source.id === d.target.id && link.target.id === d.source.id)
        );

        const sourceNode = d.source;
        const targetNode = d.target;

        const x1 = sourceNode.x;
        const y1 = sourceNode.y;
        const x2 = targetNode.x;
        const y2 = targetNode.y;

        const dx = x2 - x1;
        const dy = y2 - y1;
        const distance = Math.sqrt(dx * dx + dy * dy);

        const edgeIndex = linksBetweenNodes.findIndex(link => link === d);
        const totalEdges = linksBetweenNodes.length;

        const offset = (edgeIndex - (totalEdges - 1) / 2) * 30; // Adjust offset

        const cx = x1 + dx / 2 - dy * (offset / distance);
        const cy = y1 + dy / 2 + dx * (offset / distance);

        return `M${x1},${y1} Q${cx},${cy} ${x2},${y2}`;
    }

    // Update positions
    function ticked() {
        link.attr('d', (d, i) => computePath(d, i));

        node.attr('transform', d => `translate(${d.x},${d.y})`);

        edgeLabels.attr('x', d => {
            const midpoint = {
                x: (d.source.x + d.target.x) / 2,
                y: (d.source.y + d.target.y) / 2,
            };
            return midpoint.x;
        }).attr('y', d => {
            const linksBetweenNodes = links.filter(link =>
                (link.source.id === d.source.id && link.target.id === d.target.id) ||
                (link.source.id === d.target.id && link.target.id === d.source.id)
            );

            const edgeIndex = linksBetweenNodes.findIndex(link => link === d);
            const totalEdges = linksBetweenNodes.length;

            const offset = (edgeIndex - (totalEdges - 1) / 2) * 20; // Adjust offset for labels
            const midpoint = {
                x: (d.source.x + d.target.x) / 2,
                y: (d.source.y + d.target.y) / 2,
            };
            return midpoint.y + offset;
        });
    }

    function dragStarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
    }

    function dragEnded(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }
</script>

</body>
</html>
